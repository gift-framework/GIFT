You are working on the GIFT framework (Geometric Information Field Theory), version 2.2, to build a new notebook:

    K7_GIFT_v1_4_TCS_full.ipynb

This notebook must construct a **numerical G₂/TCS metric on K₇** with:

- exact cohomological structure b₂=21, b₃=77,
- fixed torsion magnitude κ_T = 1/61,
- fixed metric determinant det(g) = 65/32,
- zero free physical “fit” parameters (only training hyperparameters).

You have access to the following files:

- GIFT 2.2 main + supplements:
dev/v2.2/publications

- Previous K₇ metric notebooks and results:
G2_ML/

Use these as references and, where useful, to warm-start the new model.

---

## High-level objective

Build a Colab/Jupyter notebook `K7_GIFT_v1_4_TCS_full.ipynb` that:

1. **Keeps what already works from v1.3c** copy what's needed from it:
   - multi-phase training,
   - stable G₂ geometry and SPD metric,
   - κ_T ≈ 1/61,
   - good numerical behavior of det(g).

2. **Moves beyond “flat T⁷” to a genuine TCS K₇ geometry**:
   - explicitly distinguish TCS blocks and a neck region,
   - break the degeneracy of a purely flat T⁷ product so that b₃=77 can be realized numerically (not just b₃=35).

3. **Imposes the GIFT 2.2 structural constants as hard constraints**:
   - b₂(K₇) = 21,  b₃(K₇) = 77, H* = 99,
   - κ_T = 1/(77 − 14 − 2) = 1/61,
   - det(g) = 65/32,
   - τ = 3472/891,
   all derived from the integer structure in the provided docs.

4. **Performs a full harmonic extraction**:
   - numerically obtain b₂_eff ≈ 21 and b₃_eff ≈ 77 from Gram matrices built with the learned metric,
   - with clear eigenvalue spectra showing 21 and 77 independent harmonic directions.

5. **Prepares the geometry for Yukawa / mass hierarchy analysis**:
   - compute some Yukawa-type integrals on the 3-form basis,
   - map them to dimensionless mass ratios using τ and κ_T, without introducing any new adjustable physical parameter.

---

## Structural constants (to encode in code)

Create a `StructuralConstants` dataclass (or similar) derived directly from the integer structure in the docs:

- p2          = 2
- N_gen       = 3
- dim_K7      = 7
- dim_G2      = 14
- rank_E8     = 8
- dim_E8      = 248
- Weyl_factor = 5
- b2_K7       = 21
- b3_K7       = 77
- H_star      = 1 + b2_K7 + b3_K7 = 99
- M5          = 31

Then define a small helper class, e.g. `ZeroParamGeometry`, that computes:

- kappa_T = 1 / (b3_K7 − dim_G2 − p2)     # = 1/61
- det_g_target = p2 + 1/(b2_K7 + dim_G2 − N_gen)  # = 65/32
- tau = 3472/891  (also expressible as 496*21/(27*99))

All these quantities must be derived from the integers above, not hard-coded floats.

---

## Geometry: from “almost T⁷” to explicit TCS K₇

Use S1 and S3 as guides to implement a more faithful TCS K₇ chart and G₂ structure.

1. **Coordinates and regions**:
   - Introduce an explicit neck coordinate λ ∈ [−L, L] with L>0 (e.g. L=1 or 2),
   - Distinguish:
     - a “left” ACyl-like region (approx. M₁ × S¹),
     - a “right” ACyl-like region (approx. M₂ × S¹),
     - a central gluing neck where twist / matching happens.

2. **Base 3-form φ**:
   - Start from a standard G₂ 3-form on T⁷ in an orthonormal frame,
   - Modify it by:
     - applying a twist map in the neck,
     - allowing different warp factors or mixing in the left vs right regions.
   - Ensure φ is globally defined but not reducible to a purely flat “constant coefficient” T⁷ form.

3. **Metric g(φ)**:
   - Use the more rigorous φ → g construction from v1.3c and S6:
     - compute g_ij ∼ δ_ij + α φ_{i k l} φ_{j m n} g^{km} g^{ln} (or a well-motivated G₂ formula),
     - symmetrize,
     - enforce SPD via eigen-decomposition and clamping if necessary.
   - Do not revert to a trivial identity metric; g should genuinely reflect the TCS geometry and vary across λ.

4. **Exterior derivatives and torsion**:
   - Implement dφ and d*φ using finite differences on the coordinate grid, with antisymmetrization to respect wedge structure,
   - Define torsion norm:
     - T² = ||dφ||² + ||d*φ||²
   - Make sure the implementation is consistent with the formulations in S3 and S6.

---

## Loss functions and training

Design a `compute_losses` function that combines:

1. **Torsion magnitude constraint** (global):
   - Loss_kappa = (⟨T⟩ − kappa_T)²,
   - Where ⟨T⟩ is an average torsion norm over sampled points.

2. **Closure / coclosure**:
   - Loss_closure = ⟨||dφ||²⟩,
   - Loss_coclosure = ⟨||d*φ||²⟩,
   - optionally weighted to keep them small but non-zero in a controlled way (since torsion ≠ 0).

3. **Metric determinant constraint**:
   - Loss_det = (⟨det(g)⟩ − det_g_target)²,
   - Optionally a regularizer on var(det(g)) to keep it tightly concentrated around 65/32.

4. **SPD / conditioning**:
   - Penalty on negative eigenvalues of g,
   - Optionally a mild penalty on condition number of g.

5. **Anti-flat regularizer**:
   - Add a term that discourages the metric from collapsing to a flat T⁷ product:
     - e.g. encourage variation of certain components along λ,
     - or penalize overly small gradient norms of g in the neck region.

Structure the training into phases as in v1.3c:

- Phase 1: coarser enforcement (torsion down, metric SPD),
- Phase 2: tighten κ_T and det(g),
- Phase 3–4: refine G₂ structure, break flat degeneracy, improve harmonic structure.

Allow warm-starting from `models.pt` when possible (i.e., load compatible weights from v1.3c).

---

## Harmonic basis and Betti extraction (b₂ = 21, b₃ = 77)

Implement a robust numerical extraction of harmonic forms:

1. **Candidate basis of 2-forms**:
   - Use the 21 coordinate wedge forms (dx^i ∧ dx^j) as in v1.3c.
   - Build Gram₂(ω_a, ω_b) = ∫ ω_a ∧ *ω_b using the learned metric g, approximated by Monte Carlo over sampled points.

2. **Candidate basis of 3-forms** (dimension 77):
   - Start from the 35 coordinate wedge forms (dx^i ∧ dx^j ∧ dx^k),
   - Add 42 extra TCS-adapted modes, for example:
     - forms with support localized in the neck region,
     - forms that differ in the left vs right ACyl regions (e.g. modulated by smooth bump functions of λ),
     - combinations reflecting the block structure suggested in S1/S3.
   - The goal is that these 77 candidates span the expected H³(K₇).

3. **Gram matrices and rank estimation**:
   - Compute Gram₂ and Gram₃ with the learned metric.
   - Use eigenvalue decomposition or SVD to estimate effective ranks:
     - b2_eff = rank(Gram₂),
     - b3_eff = rank(Gram₃).
   - Print:
     - condition numbers κ(Gram₂), κ(Gram₃),
     - eigenvalue ranges,
     - b2_eff, b3_eff versus the targets 21, 77.

The notebook should aim to reach b2_eff ≈ 21 and b3_eff ≈ 77 in at least one well-trained run (or report how close it gets).

---

## τ and Yukawa integrals (geometry → hierarchies)

Add a lightweight analysis block at the end:

1. Implement a `TauLayer` or similar that:

   - stores τ = 3472/891,
   - provides a function `yukawa_to_mass_ratio(Y_geom, sector)` that maps a dimensionless Yukawa integral Y_geom to a mass ratio using only the structural constants (p2, N_gen, dim_K7, etc., κ_T, τ).

2. Implement a function to compute geometric Yukawa-type integrals:

   - choose a few triplets of 3-forms (e.g. from the visible 43-dimensional subspace suggested by the docs),
   - compute
     Y_geom = ∫ φ_i ∧ φ_j ∧ φ_k
     numerically using the learned metric and sampled points.

3. For each chosen triplet, use `yukawa_to_mass_ratio` to compute predicted mass ratios (e.g. m_s/m_d, m_c/m_s) and compare to the exact integer ratios listed in GIFT v2.2 (purely as a diagnostic, not as a fit).

This step is optional for training but important for demonstrating that the learned K₇ geometry can in principle support the mass hierarchy structure.

---

## Outputs

At the end of the notebook, save:

- models_v1_4.pt       (trained weights),
- coords_v1_4.npy      (sampled coords),
- metric_v1_4.npy      (metrics),
- history_v1_4.csv     (phase, epoch, losses, ||T||, det(g), etc.),
- metadata_v1_4.json   (p2, N_gen, b2_eff, b3_eff, kappa_T, det_g, tau),
- results_v1_4.tex     (summary: κ_T vs 1/61, det(g) vs 65/32, b₂/b₃, Yukawa table).

Structure the notebook as an ordered sequence of Markdown and Python cells, clean and modular, ready to run in Colab.

Do not introduce any new continuous physical parameter. The only tunable quantities should be:
- network architecture choices,
- optimizer settings,
- batch sizes,
- phase schedules.

All physical outputs must be functions of the fixed integers and derived rationals described above.

attention à bien gérer ta mémoire et ne pas atteindre la limite de 32k tokens. créé le notebook vide dans G2_ML/1_4/ puis ajoute chaque cellule, prompt par prompt stp :) et pour les checkpoints fais-en des individuels touls les 1000 qu'on puisse repartir d'un précédent si ça diverge (comme dans 1.2x le système checkpoint/resume...)